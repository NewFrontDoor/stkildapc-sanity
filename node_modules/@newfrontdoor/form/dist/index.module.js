import React from 'react';
import { Field, Form, useField } from 'react-final-form';
import arrayMutators from 'final-form-arrays';
import { FieldArray } from 'react-final-form-arrays';
import PropTypes from 'prop-types';
import { jsx, Label, Input, Button, Checkbox, Radio, Select, Box, Styled, Grid, Textarea, Text } from 'theme-ui';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var Error = function Error(_ref) {
  var name = _ref.name;

  var _useField = useField(name, {
    subscription: {
      touched: true,
      error: true
    }
  }),
      _useField$meta = _useField.meta,
      touched = _useField$meta.touched,
      error = _useField$meta.error;

  return touched && error ? jsx(Text, {
    variant: "warning",
    mb: 2
  }, error) : null;
};

Error.propTypes = {
  name: PropTypes.string.isRequired
};

var handleReset = function handleReset(event, form) {
  event.preventDefault();
  form.reset();
};

var NestedForm = function NestedForm(_ref2) {
  var childFields = _ref2.childFields,
      form = _ref2.form,
      childLabel = _ref2.childLabel,
      name = _ref2.name,
      fields = _ref2.fields,
      index = _ref2.index;
  return jsx("div", {
    key: name,
    sx: {
      gridColumn: '1/3'
    }
  }, jsx("fieldset", {
    sx: {
      display: 'contents'
    }
  }, childLabel && jsx(Styled.h4, null, childLabel, " ", index + 1), childFields.map(function (field) {
    return getFormField(field, form, name);
  }), jsx(Button, {
    type: "button",
    onClick: function onClick() {
      return fields.remove(index);
    }
  }, "Remove")));
};

NestedForm.propTypes = {
  childFields: PropTypes.array.isRequired,
  form: PropTypes.any,
  name: PropTypes.string.isRequired,
  childLabel: PropTypes.string,
  fields: PropTypes.array.isRequired,
  index: PropTypes.number.isRequired
};

var getFormField = function getFormField(field, form, blockText, name) {
  if (name === void 0) {
    name = '';
  }

  var _form$mutators = form.mutators,
      push = _form$mutators.push,
      pop = _form$mutators.pop;
  var width = field.styling && field.styling.fullWidth ? '1/3' : null; // This is a hack while Sanity doesn't enable initial values on array-level items

  if (field.childFields) field.input = 'field-array';

  switch (field.input) {
    case 'textarea':
      return jsx(Field, {
        key: field.id,
        name: name + field.id,
        placeholder: field.placeholder
      }, function (_ref3) {
        var input = _ref3.input,
            otherProps = _objectWithoutPropertiesLoose(_ref3, ["input"]);

        return jsx("div", {
          key: field.id + field.label,
          sx: {
            gridColumn: '1/3'
          }
        }, jsx(Label, {
          htmlFor: field.id
        }, field.label), jsx(Textarea, _extends({
          id: field.id
        }, input, otherProps, {
          rows: "8"
        })), jsx(Error, {
          name: name + field.id
        }));
      });

    case 'field-array':
      return jsx(Box, {
        sx: {
          gridColumn: '1/3'
        }
      }, field.label && jsx(Styled.h2, null, field.label), field.description && blockText ? blockText(field.description) : jsx(Styled.p, null, field.description), jsx(Grid, {
        gap: 20,
        columns: ['1fr 1fr']
      }, jsx("div", {
        sx: {
          display: 'flex',
          justifyContent: 'space-evenly'
        }
      }, jsx(Button, {
        type: "button",
        sx: {
          width: '35%'
        },
        onClick: function onClick() {
          return push(name + field.id, undefined);
        }
      }, "Add"), jsx(Button, {
        type: "button",
        sx: {
          width: '35%'
        },
        onClick: function onClick() {
          return pop(name + field.id, undefined);
        }
      }, "Remove")), jsx(FieldArray, {
        name: name + field.id
      }, function (_ref4) {
        var fields = _ref4.fields;
        return fields.map(function (name, index) {
          return jsx(NestedForm, {
            key: name + field.id,
            childLabel: field.childLabel,
            name: name,
            form: form,
            fields: fields,
            index: index,
            childFields: field.childFields
          });
        });
      })));

    case 'select':
      return jsx(Field, {
        key: field.id,
        name: name + field.id
      }, function (_ref5) {
        var input = _ref5.input,
            otherProps = _objectWithoutPropertiesLoose(_ref5, ["input"]);

        return jsx("div", {
          key: field.id + field.label,
          sx: {
            gridColumn: width
          }
        }, jsx(Label, {
          htmlFor: field.id
        }, field.label), jsx(Select, _extends({
          id: field.id
        }, input, otherProps), field.values.map(function (value) {
          return jsx("option", {
            key: field.id + value,
            value: value
          }, value);
        })), jsx(Error, {
          name: name + field.id
        }));
      });

    case 'radio':
      return jsx("fieldset", {
        key: field.id,
        sx: {
          gridColumn: width
        }
      }, jsx("legend", {
        sx: {
          gridColumn: '1/3'
        }
      }, field.label), field.values.map(function (value) {
        return jsx("div", {
          key: field.id + value
        }, jsx("label", {
          key: value,
          sx: {
            boxSizing: 'border-box',
            minWidth: '0px',
            width: '100%',
            display: 'flex',
            margin: '0px'
          }
        }, jsx(Field, {
          name: name + field.id,
          type: "radio",
          value: value
        }, function (_ref6) {
          var input = _ref6.input,
              otherProps = _objectWithoutPropertiesLoose(_ref6, ["input"]);

          return jsx(Radio, _extends({}, input, otherProps));
        }), value));
      }));

    case 'checkbox':
      return jsx(React.Fragment, null, field.label && field.values && field.values.length > 0 ? jsx("fieldset", {
        key: field.id,
        sx: {
          gridColumn: width
        }
      }, jsx("legend", {
        sx: {
          gridColumn: '1/3'
        }
      }, field.label), field.values.map(function (value) {
        return jsx("div", {
          key: field.id + value
        }, jsx("label", {
          key: value,
          sx: {
            boxSizing: 'border-box',
            minWidth: '0px',
            width: '100%',
            display: 'flex',
            margin: '0px'
          }
        }, jsx(Field, {
          name: name + field.id,
          value: value
        }, function (_ref7) {
          var input = _ref7.input,
              otherProps = _objectWithoutPropertiesLoose(_ref7, ["input"]);

          return jsx(Checkbox, _extends({}, input, otherProps));
        }), value));
      })) : jsx("div", {
        key: field.id + field.label,
        sx: {
          gridColumn: width
        }
      }, jsx(Label, {
        sx: {
          display: 'inline-block'
        }
      }, jsx(Field, {
        key: field.id,
        name: name + field.id
      }, function (_ref8) {
        var input = _ref8.input,
            otherProps = _objectWithoutPropertiesLoose(_ref8, ["input"]);

        return jsx(Checkbox, _extends({}, input, otherProps));
      }), field.label, jsx(Error, {
        name: name + field.id
      }))));

    case 'reset':
      return jsx(Button, {
        sx: {
          gridColumn: width
        },
        type: field.input,
        id: field.id,
        onClick: function onClick(event) {
          return handleReset(event, form);
        }
      }, field.label);

    default:
      return jsx(Field, {
        key: name + field.id,
        name: name + field.id,
        placeholder: field.placeholder
      }, function (_ref9) {
        var input = _ref9.input,
            otherProps = _objectWithoutPropertiesLoose(_ref9, ["input"]);

        return jsx("div", {
          key: field.id + field.label,
          sx: {
            gridColumn: width
          }
        }, jsx(Label, {
          htmlFor: field.id,
          required: field.required
        }, field.label, field.required && jsx("strong", null, "*")), jsx(Input, _extends({
          type: field.input,
          id: field.id
        }, input, otherProps)), jsx(Error, {
          name: name + field.id
        }));
      });
  }
};

var FormComponent = function FormComponent(_ref10) {
  var title = _ref10.title,
      id = _ref10.id,
      description = _ref10.description,
      fields = _ref10.fields,
      blockText = _ref10.blockText,
      submitForm = _ref10.submitForm,
      validationFn = _ref10.validationFn,
      success = _ref10.success;

  var defaultTextHandler = function defaultTextHandler(content) {
    return jsx(Styled.p, null, content);
  };

  var block = blockText || defaultTextHandler;
  return jsx(Form, {
    mutators: _extends({}, arrayMutators),
    render: function render(_ref11) {
      var handleSubmit = _ref11.handleSubmit,
          form = _ref11.form,
          submitting = _ref11.submitting,
          pristine = _ref11.pristine,
          submitSucceeded = _ref11.submitSucceeded;
      return submitSucceeded ? success ? success : jsx(Box, {
        as: "form",
        id: id
      }, jsx("fieldset", null, jsx(Styled.p, null, "Thankyou for your submission. We will get back to you as soon as we can."))) : jsx(Box, {
        as: "form",
        id: id,
        onSubmit: handleSubmit
      }, jsx("fieldset", null, title && jsx(Styled.h2, null, title), description && block(description), jsx(Grid, {
        gap: 20,
        columns: ['1fr 1fr']
      }, fields.map(function (field) {
        return getFormField(field, form, block);
      }), jsx(Button, {
        sx: {
          gridColumn: '1/3'
        },
        type: "submit",
        disabled: submitting || pristine
      }, "Submit"))));
    },
    validate: validationFn,
    initialValues: fields.reduce(function (object, field) {
      if (field.initialValue) object[field.id] = field.initialValue;
      return object;
    }, {}),
    onSubmit: submitForm
  });
};

FormComponent.propTypes = {
  title: PropTypes.string.isRequired,
  id: PropTypes.string.isRequired,
  description: PropTypes.string.isRequired,
  fields: PropTypes.array.isRequired,
  blockText: PropTypes.func,
  submitForm: PropTypes.func.isRequired,
  validationFn: PropTypes.func,
  success: PropTypes.node
};

var regexLookup = {
  text: null,
  email: /([\w_.\-+])+@([\w-]+\.)+([\w]{2,10})+$/i,
  telephone: /^[+]*[(]{0,1}[0-9]{2,}[)]{0,1}[0-9]{6,}$/i,
  date: /^(0?[1-9]|1[0-2])[/](0?[1-9]|[12]d|3[01])[/](14|21)d{2}$/i,
  textarea: null,
  select: null,
  checkbox: null,
  radio: null,
  url: /[(http(s)?)://(www.)?a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/i,
  file: null,
  number: /^-?\d*\.?\d+$/i
};

var validation = function validation(values, data, regexs) {
  // If a new Regex object is supplied, use that, otherwise, use the library default
  var regexDict = regexs || regexLookup; // If an error message is supplied, use that, otherwise, use the library default

  var errorMessage = data.requiredError || 'Required'; // Define errors object

  var errors = {}; // Begin testing each field for errors

  data.fields.forEach(function (field) {
    var _field$validation, _field$validation$val, _field$validation2;

    /* ***** */

    /* Setup */

    /* ***** */
    // If supplied regex, put it into variable - otherwise false
    var rg = field == null ? void 0 : (_field$validation = field.validation) == null ? void 0 : _field$validation.regexString; // Test the supplied regex, return if regex, or make regex, or return false

    var suppliedRegex = rg instanceof RegExp ? rg : rg && new RegExp(rg) instanceof RegExp // If rg && not included, this would evaluate true
    ? new RegExp(rg) : false; // If supplied validation type, put it into variable - otherwise false

    var vtype = (_field$validation$val = field == null ? void 0 : (_field$validation2 = field.validation) == null ? void 0 : _field$validation2.validationType) != null ? _field$validation$val : false; // Set the regex based on vtype and suppliedRegex value

    var regex = vtype === 'custom' ? suppliedRegex : vtype === 'default' ? regexDict[field.input] : false;
    /* ***** */

    /* Tests */

    /* ***** */
    // Test for value against required, if met, test against regex (if applicable)

    if (field.required) {
      if (!values[field.id]) {
        errors[field.id] = errorMessage;
      } else if (regex && !regex.test(values[field.id])) {
        errors[field.id] = field.validation.warning;
      }
    } // Given value not required, if value, test against regex (if valid regex)


    if (!field.required) {
      if (regex && values[field.id] && !regex.test(values[field.id])) {
        console.log('inside');
        errors[field.id] = field.validation.warning;
      }
    }
  }); // Returns error object as result of validation to react-final-form

  return errors;
};

export { FormComponent as Form, regexLookup as RegexLookup, getFormField, validation };
//# sourceMappingURL=index.module.js.map
