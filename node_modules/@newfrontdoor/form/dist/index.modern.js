import React from 'react';
import { Field, Form, useField } from 'react-final-form';
import arrayMutators from 'final-form-arrays';
import { FieldArray } from 'react-final-form-arrays';
import PropTypes from 'prop-types';
import { jsx, Label, Input, Button, Checkbox, Radio, Select, Box, Styled, Grid, Textarea, Text } from 'theme-ui';

/** @jsx jsx */

const Error = ({
  name
}) => {
  const {
    meta: {
      touched,
      error
    }
  } = useField(name, {
    subscription: {
      touched: true,
      error: true
    }
  });
  return touched && error ? jsx(Text, {
    variant: "warning",
    mb: 2
  }, error) : null;
};

Error.propTypes = {
  name: PropTypes.string.isRequired
};

const handleReset = (event, form) => {
  event.preventDefault();
  form.reset();
};

const NestedForm = ({
  childFields,
  form,
  childLabel,
  name,
  fields,
  index
}) => {
  return jsx("div", {
    key: name,
    sx: {
      gridColumn: '1/3'
    }
  }, jsx("fieldset", {
    sx: {
      display: 'contents'
    }
  }, childLabel && jsx(Styled.h4, null, childLabel, " ", index + 1), childFields.map(field => {
    return getFormField(field, form, name);
  }), jsx(Button, {
    type: "button",
    onClick: () => fields.remove(index)
  }, "Remove")));
};

NestedForm.propTypes = {
  childFields: PropTypes.array.isRequired,
  form: PropTypes.any,
  name: PropTypes.string.isRequired,
  childLabel: PropTypes.string,
  fields: PropTypes.array.isRequired,
  index: PropTypes.number.isRequired
};

const getFormField = (field, form, blockText, name = '') => {
  const {
    push,
    pop
  } = form.mutators;
  const width = field.styling && field.styling.fullWidth ? '1/3' : null; // This is a hack while Sanity doesn't enable initial values on array-level items

  if (field.childFields) field.input = 'field-array';

  switch (field.input) {
    case 'textarea':
      return jsx(Field, {
        key: field.id,
        name: name + field.id,
        placeholder: field.placeholder
      }, ({
        input,
        ...otherProps
      }) => jsx("div", {
        key: field.id + field.label,
        sx: {
          gridColumn: '1/3'
        }
      }, jsx(Label, {
        htmlFor: field.id
      }, field.label), jsx(Textarea, Object.assign({
        id: field.id
      }, input, otherProps, {
        rows: "8"
      })), jsx(Error, {
        name: name + field.id
      })));

    case 'field-array':
      return jsx(Box, {
        sx: {
          gridColumn: '1/3'
        }
      }, field.label && jsx(Styled.h2, null, field.label), field.description && blockText ? blockText(field.description) : jsx(Styled.p, null, field.description), jsx(Grid, {
        gap: 20,
        columns: ['1fr 1fr']
      }, jsx("div", {
        sx: {
          display: 'flex',
          justifyContent: 'space-evenly'
        }
      }, jsx(Button, {
        type: "button",
        sx: {
          width: '35%'
        },
        onClick: () => push(name + field.id, undefined)
      }, "Add"), jsx(Button, {
        type: "button",
        sx: {
          width: '35%'
        },
        onClick: () => pop(name + field.id, undefined)
      }, "Remove")), jsx(FieldArray, {
        name: name + field.id
      }, ({
        fields
      }) => fields.map((name, index) => jsx(NestedForm, {
        key: name + field.id,
        childLabel: field.childLabel,
        name: name,
        form: form,
        fields: fields,
        index: index,
        childFields: field.childFields
      })))));

    case 'select':
      return jsx(Field, {
        key: field.id,
        name: name + field.id
      }, ({
        input,
        ...otherProps
      }) => jsx("div", {
        key: field.id + field.label,
        sx: {
          gridColumn: width
        }
      }, jsx(Label, {
        htmlFor: field.id
      }, field.label), jsx(Select, Object.assign({
        id: field.id
      }, input, otherProps), field.values.map(value => jsx("option", {
        key: field.id + value,
        value: value
      }, value))), jsx(Error, {
        name: name + field.id
      })));

    case 'radio':
      return jsx("fieldset", {
        key: field.id,
        sx: {
          gridColumn: width
        }
      }, jsx("legend", {
        sx: {
          gridColumn: '1/3'
        }
      }, field.label), field.values.map(value => jsx("div", {
        key: field.id + value
      }, jsx("label", {
        key: value,
        sx: {
          boxSizing: 'border-box',
          minWidth: '0px',
          width: '100%',
          display: 'flex',
          margin: '0px'
        }
      }, jsx(Field, {
        name: name + field.id,
        type: "radio",
        value: value
      }, ({
        input,
        ...otherProps
      }) => jsx(Radio, Object.assign({}, input, otherProps))), value))));

    case 'checkbox':
      return jsx(React.Fragment, null, field.label && field.values && field.values.length > 0 ? jsx("fieldset", {
        key: field.id,
        sx: {
          gridColumn: width
        }
      }, jsx("legend", {
        sx: {
          gridColumn: '1/3'
        }
      }, field.label), field.values.map(value => jsx("div", {
        key: field.id + value
      }, jsx("label", {
        key: value,
        sx: {
          boxSizing: 'border-box',
          minWidth: '0px',
          width: '100%',
          display: 'flex',
          margin: '0px'
        }
      }, jsx(Field, {
        name: name + field.id,
        value: value
      }, ({
        input,
        ...otherProps
      }) => jsx(Checkbox, Object.assign({}, input, otherProps))), value)))) : jsx("div", {
        key: field.id + field.label,
        sx: {
          gridColumn: width
        }
      }, jsx(Label, {
        sx: {
          display: 'inline-block'
        }
      }, jsx(Field, {
        key: field.id,
        name: name + field.id
      }, ({
        input,
        ...otherProps
      }) => jsx(Checkbox, Object.assign({}, input, otherProps))), field.label, jsx(Error, {
        name: name + field.id
      }))));

    case 'reset':
      return jsx(Button, {
        sx: {
          gridColumn: width
        },
        type: field.input,
        id: field.id,
        onClick: event => handleReset(event, form)
      }, field.label);

    default:
      return jsx(Field, {
        key: name + field.id,
        name: name + field.id,
        placeholder: field.placeholder
      }, ({
        input,
        ...otherProps
      }) => jsx("div", {
        key: field.id + field.label,
        sx: {
          gridColumn: width
        }
      }, jsx(Label, {
        htmlFor: field.id,
        required: field.required
      }, field.label, field.required && jsx("strong", null, "*")), jsx(Input, Object.assign({
        type: field.input,
        id: field.id
      }, input, otherProps)), jsx(Error, {
        name: name + field.id
      })));
  }
};

const FormComponent = ({
  title,
  id,
  description,
  fields,
  blockText,
  submitForm,
  validationFn,
  success
}) => {
  const defaultTextHandler = content => {
    return jsx(Styled.p, null, content);
  };

  const block = blockText || defaultTextHandler;
  return jsx(Form, {
    mutators: { ...arrayMutators
    },
    render: ({
      handleSubmit,
      form,
      submitting,
      pristine,
      submitSucceeded
    }) => {
      return submitSucceeded ? success ? success : jsx(Box, {
        as: "form",
        id: id
      }, jsx("fieldset", null, jsx(Styled.p, null, "Thankyou for your submission. We will get back to you as soon as we can."))) : jsx(Box, {
        as: "form",
        id: id,
        onSubmit: handleSubmit
      }, jsx("fieldset", null, title && jsx(Styled.h2, null, title), description && block(description), jsx(Grid, {
        gap: 20,
        columns: ['1fr 1fr']
      }, fields.map(field => {
        return getFormField(field, form, block);
      }), jsx(Button, {
        sx: {
          gridColumn: '1/3'
        },
        type: "submit",
        disabled: submitting || pristine
      }, "Submit"))));
    },
    validate: validationFn,
    initialValues: fields.reduce((object, field) => {
      if (field.initialValue) object[field.id] = field.initialValue;
      return object;
    }, {}),
    onSubmit: submitForm
  });
};

FormComponent.propTypes = {
  title: PropTypes.string.isRequired,
  id: PropTypes.string.isRequired,
  description: PropTypes.string.isRequired,
  fields: PropTypes.array.isRequired,
  blockText: PropTypes.func,
  submitForm: PropTypes.func.isRequired,
  validationFn: PropTypes.func,
  success: PropTypes.node
};

var regexLookup = {
  text: null,
  email: /([\w_.\-+])+@([\w-]+\.)+([\w]{2,10})+$/i,
  telephone: /^[+]*[(]{0,1}[0-9]{2,}[)]{0,1}[0-9]{6,}$/i,
  date: /^(0?[1-9]|1[0-2])[/](0?[1-9]|[12]d|3[01])[/](14|21)d{2}$/i,
  textarea: null,
  select: null,
  checkbox: null,
  radio: null,
  url: /[(http(s)?)://(www.)?a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/i,
  file: null,
  number: /^-?\d*\.?\d+$/i
};

const validation = (values, data, regexs) => {
  // If a new Regex object is supplied, use that, otherwise, use the library default
  const regexDict = regexs || regexLookup; // If an error message is supplied, use that, otherwise, use the library default

  const errorMessage = data.requiredError || 'Required'; // Define errors object

  const errors = {}; // Begin testing each field for errors

  data.fields.forEach(field => {
    /* ***** */

    /* Setup */

    /* ***** */
    // If supplied regex, put it into variable - otherwise false
    const rg = field?.validation?.regexString; // Test the supplied regex, return if regex, or make regex, or return false

    const suppliedRegex = rg instanceof RegExp ? rg : rg && new RegExp(rg) instanceof RegExp // If rg && not included, this would evaluate true
    ? new RegExp(rg) : false; // If supplied validation type, put it into variable - otherwise false

    const vtype = field?.validation?.validationType ?? false; // Set the regex based on vtype and suppliedRegex value

    const regex = vtype === 'custom' ? suppliedRegex : vtype === 'default' ? regexDict[field.input] : false;
    /* ***** */

    /* Tests */

    /* ***** */
    // Test for value against required, if met, test against regex (if applicable)

    if (field.required) {
      if (!values[field.id]) {
        errors[field.id] = errorMessage;
      } else if (regex && !regex.test(values[field.id])) {
        errors[field.id] = field.validation.warning;
      }
    } // Given value not required, if value, test against regex (if valid regex)


    if (!field.required) {
      if (regex && values[field.id] && !regex.test(values[field.id])) {
        console.log('inside');
        errors[field.id] = field.validation.warning;
      }
    }
  }); // Returns error object as result of validation to react-final-form

  return errors;
};

export { FormComponent as Form, regexLookup as RegexLookup, getFormField, validation };
//# sourceMappingURL=index.modern.js.map
