"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DefaultPlayer;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _customHooks = require("./custom-hooks");

var _core = require("@emotion/core");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function DefaultPlayer(_ref) {
  var {
    autoPlay,
    children,
    className,
    controls,
    crossOrigin,
    controlsList,
    id,
    listenInterval,
    loop,
    preload,
    src,
    style,
    title,
    muted,
    volume,
    onError,
    onCanPlay,
    onCanPlayThrough,
    onPlay,
    onPlaying,
    onTimeUpdate,
    onDurationChange,
    onAbort,
    onEnded,
    onPause,
    onListen,
    onSeeked,
    onVolumeChange,
    onLoadedMetadata,
    setAudioPlayer
  } = _ref;
  var audioEl = (0, _react.useRef)();
  var [audio, setElement] = (0, _react.useState)(null);
  var listeners = [['error', onError], ['canplay', onCanPlay], ['canplaythrough', onCanPlayThrough], ['play', onPlay], ['playing', onPlaying], ['abort', onAbort], ['ended', onEnded], ['pause', onPause], ['seeked', onSeeked], ['loadedmetadata', onLoadedMetadata], ['volumechange', onVolumeChange], ['timeupdate', onTimeUpdate], ['durationchange', onDurationChange]];
  listeners.map((_ref2) => {
    var [name, fn] = _ref2;
    return (0, _customHooks.useEventListener)(name, e => {
      fn(e);
    }, audio);
  });
  (0, _react.useEffect)(() => {
    setElement(audioEl.current);

    if (setAudioPlayer) {
      setAudioPlayer(audioEl.current);
    }
  }, [audioEl, setAudioPlayer]);
  (0, _react.useEffect)(() => {
    if (audio) {
      if (typeof volume === 'number' && volume !== audio.volume) {
        audio.volume = volume;
      }
    }
  }, [volume, audio]);
  return (0, _core.jsx)("audio", {
    ref: audioEl,
    autoPlay: autoPlay,
    controls: !(controls === false),
    crossOrigin: crossOrigin,
    id: id,
    loop: loop,
    muted: muted,
    className: "react-audio-player ".concat(className),
    title: title || src,
    preload: preload,
    controlsList: controlsList,
    src: src,
    style: style,
    onPlaying: onPlaying,
    onPlay: onPlay
  }, children || (0, _core.jsx)("p", null, "Your browser does not support the", (0, _core.jsx)("code", null, "audio"), "element."));
}

DefaultPlayer.defaultProps = {
  autoPlay: false,
  children: null,
  className: '',
  controls: false,
  controlsList: '',
  crossOrigin: null,
  id: '',
  listenInterval: 10000,
  loop: false,
  muted: false,
  onAbort: () => {},
  onCanPlay: () => {},
  onCanPlayThrough: () => {},
  onEnded: () => {},
  onError: () => {},
  onListen: () => {},
  onPause: () => {},
  onPlay: () => {},
  onSeeked: () => {},
  onVolumeChange: () => {},
  onLoadedMetadata: () => {},
  onDurationChange: () => {},
  setAudioPlayer: () => {},
  preload: 'metadata',
  src: null,
  style: {},
  title: '',
  volume: 0.4
};
DefaultPlayer.propTypes = {
  autoPlay: _propTypes.default.bool,
  children: _propTypes.default.element,
  className: _propTypes.default.string,
  controls: _propTypes.default.bool,
  controlsList: _propTypes.default.string,
  crossOrigin: _propTypes.default.string,
  id: _propTypes.default.string,
  listenInterval: _propTypes.default.number,
  loop: _propTypes.default.bool,
  muted: _propTypes.default.bool,
  onAbort: _propTypes.default.func,
  onCanPlay: _propTypes.default.func,
  onCanPlayThrough: _propTypes.default.func,
  onEnded: _propTypes.default.func,
  onError: _propTypes.default.func,
  onListen: _propTypes.default.func,
  onLoadedMetadata: _propTypes.default.func,
  onPause: _propTypes.default.func,
  onPlay: _propTypes.default.func,
  onSeeked: _propTypes.default.func,
  onVolumeChange: _propTypes.default.func,
  setAudioPlayer: _propTypes.default.func,
  preload: _propTypes.default.oneOf(['', 'none', 'metadata', 'auto']),
  src: _propTypes.default.string,
  // Not required b/c can use <source>
  style: _propTypes.default.objectOf(_propTypes.default.string),
  title: _propTypes.default.string,
  volume: _propTypes.default.number
};